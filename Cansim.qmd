---
title: 'Cansim Library for Socio-Economic data'
author: "Dave Campbell"
date: '2021-06-11'
slug: socioeconomic-time-series-and-statistics-canada
categories: ["Census Data"]
tags: ["Linear Regression", "Time Series",  "Official Statistics", "Census Data"]
subtitle: ''
summary: 'Using R libraries to acquire socioeconomic data from Statistics Canada Mapper.'
lastmod: '2021-06-11T18:40:19-04:00'
---
  
# Possible Analysis and Keywords

- Regular Expressions
- String Manipulation
- Merging Datasets
- Socioeconomic Data
- Canadian Data
- Regression
- Housing




# Goals

Find and extract socio-economic data from Statistics Canada.  In this example we manipulate and plot unemployment rates and housing starts.  Relationships between the two datasets are examined.


# Data Provider

Statistics Canada hosts a large set of socio-economic [datasets](https://www150.statcan.gc.ca/n1//en/type/data?MM=1#tables).  When searching through these, take note of the _table_ identifier.  The **stats-can** package provides an API for downloading these tables.  See also the 
[stats-can](https://stats-can.readthedocs.io/en/latest/) vignette for examples and instructions to pull Statistics Canada datasets.

# Installing stats-can
  
  
  
```{python stats-can library, eval=FALSE}

#code not run for this document.
```

# Basic libraries 

```{python libraries}
from stats_can import StatsCan # for pulling Stats Can socioeconomic data
import pandas as pd # for data wrangling
import seaborn as sb # for plotting
import matplotlib.pyplot as plt # for plot management

```

## Pulling a table

Visit [here](https://www150.statcan.gc.ca/t1/tbl1/en/tv.action?pid=1410028701&pickMembers%5B0%5D=1.1&pickMembers%5B1%5D=3.1&pickMembers%5B2%5D=4.1&pickMembers%5B3%5D=5.1&cubeTimeFrame.startMonth=01&cubeTimeFrame.startYear=1976&cubeTimeFrame.endMonth=01&cubeTimeFrame.endYear=2021&referencePeriods=19760101%2C20210101) for example to see labor force data in html.
Notice that the StatCan webpage shows the table id, here it is table: 14-10-0287-01.

We'll use that to grab the table.   Be warned that this data table is a csv of around 1 GB in size.   

```{python}
sc = StatsCan() # We create a StatsCan Object that will be used to pull data
data = sc.table_to_df("14-10-0287-01") 
data.head()
```

There are nearly 5 million rows of data!  


## Make a few plots of Employment statistics


Stat Can tables are structured so that each row has a single value and columns define attributes about that value  Each row of data has a specific attribute sex, age (**Age.group**), and Location (**GEO**) attributes, for units of the value (**SCALAR_FACTOR**), the specific type of labour force characteristic measured (**Labour.force.characteristics**), and the differences data types such as point estimates and (bootstrap) standard errors (**Statistics**), and raw or seasonally adjusted (**Data.type**).  In general this means that we need to filter and reshape the data.  

Let's inventory a few of these columns so that the exact spelling of attributes can be used below in the plots.


```{python}

data["Labour force characteristics"].unique()

```

```{python}

data["Statistics"].unique()

```

```{python}

data["Age group"].unique()

```

```{python}

data["GEO"].unique()

```

```{python}

data["Data type"].unique()

```

### Plotting provinces against each other
Let's consider provincial differences in employment rate for 25-55 year olds.  Using the spelling from the above output we can set up the data filters.

##### Important consideration when pivoting
Pivoting a data table will spread out a variable into new columns. Sometimes it's more convenient to have each province as it's own column.  Here we do this to plot provinces against each other and see how they relate. In this case, we want each province's unemployment rate from the "Labour force characteristics" column. However, notice that there is a "Data type" column that shows two possible entries for the unemployment rate attribute in the "Labour force characteristics". If we filtered the data without selected one of these Data types, and then pivoted, python would take the mean of these two values! 

```{python employmentprovinces0}

provinces = data[["GEO",
                  "Sex",
                  "Age group",
                  "Labour force characteristics",
                  "REF_DATE",
                  "VALUE",
                  "Data type"]]

provinces = provinces[(provinces["Sex"] == "Both sexes") &
                      (provinces["GEO"] != "Canada") &
                      (provinces["Labour force characteristics"] == "Unemployment rate") &
                      (provinces["Age group"] == "25 to 54 years") &
                      (provinces["Data type"] == "Unadjusted")]


pivoted = pd.pivot_table(provinces,
                         index = ["Sex",
                                  "Age group",
                                  "Labour force characteristics",
                                  "REF_DATE"],
                         values = "VALUE",
                         columns = "GEO").reset_index()

```

```{python employmentprovincespairplot}

sb.pairplot(pivoted, vars = pivoted.columns[4:14])
plt.show()
# add title

```

### Plotting the Provinces as Time Series

```{python unemployment by province}

provinces["month"] = provinces["REF_DATE"].dt.month
provinces["year"] = provinces["REF_DATE"].dt.year

x = list(provinces["GEO"].unique())
y = [1,2,3,4,5,6,7,8,9,10]

sb.set_style("darkgrid")

for province, i in zip(x, y):
    plt.subplot(3,4,i)
    plt.tight_layout()

    sb.lineplot(data = provinces[provinces["GEO"] == province],
                x = "year",
                y = "VALUE")
     
    
    plt.legend('', frameon = False)
    plt.title(province, fontsize = 8)
    if province == "Quebec":
        plt.ylabel("Unemployment Rate")
    else:
        plt.ylabel("") 

plt.subplots_adjust(top = 0.9)
plt.suptitle('Unemployment Rates by Province', fontsize=14)
plt.show()

```

## Plot the Within Year Seasonal Trends

```{python within year seasonal highlight pandemic}

x = list(provinces["GEO"].unique())
y = [1,2,3,4,5,6,7,8,9,10]

plt.clf()

for province, i in zip(x, y):
    plt.subplot(3,4,i)
    plt.tight_layout()
    sb.lineplot(data = provinces[(provinces["GEO"] == province) &
                                 (provinces["year"] < 2020)],
                x = "month",
                y = "VALUE",
                hue = "year",
                palette = "crest",
                linewidth = 0.5)

    sb.lineplot(data = provinces[(provinces["GEO"] == province) &
                                 (provinces["year"] >= 2020)],
                x = "month",
                y = "VALUE",
                hue = "year",
                palette = "Reds_d",
                linewidth = 2.5)
    if province == "British Columbia":
        plt.legend(title="Year", 
                   bbox_to_anchor=(1.05, 1), 
                   loc='upper left', 
                   borderaxespad=0, 
                   ncol = 3)
    else:           
        plt.legend('', frameon = False)
    plt.title(province, fontsize = 8)
    if province == "Quebec":
        plt.ylabel("Unemployment Rate")
    else:
        plt.ylabel("")        

plt.subplots_adjust(top = 0.9)
plt.suptitle('Unemployment Rates by Province: Highlighting Pandemic Years', 
             fontsize = 13)
plt.show()

```

```{python within year seasonal highlight by decade}

provinces["decade"] = provinces["year"] // 10 * 10

for province, i in zip(x, y):
    plt.subplot(3,4,i)
    plt.tight_layout()

    sb.lineplot(data = provinces[provinces["GEO"] == province],
                x = "month",
                y = "VALUE",
                hue = "decade",
                palette = "bright",
                units = "year",
                estimator = None)
     
    
    plt.legend('', frameon = False)
    plt.title(province, fontsize = 8)

    if province == "British Columbia":
        plt.legend(title="decade", 
                   bbox_to_anchor=(1.05, 1), 
                   loc='upper left', 
                   borderaxespad=0, 
                   ncol = 3)
    else:           
        plt.legend('', frameon = False)

    if province == "Quebec":
        plt.ylabel("Unemployment Rate")
    else:
        plt.ylabel("") 

plt.subplots_adjust(top = 0.9)
plt.suptitle('Unemployment Rates by Province: Highlighted by Decade', fontsize=13)
plt.show()

```

## Housing starts


The housing starts are more complicated beacuse they are based on cities but the unemployment is based on provices

```{python housing dataset}

housing = sc.table_to_df("34-10-0154-01") 
housing.head()

```

```{python unique cities}

# the unique cities
housing["GEO"].unique()

```

To merge the housing starts with the unemployment, we need to set both to the same measurement unit, provinces per {month, year}.  To construct provincial housing starts, sum over the municipailites within a province. Many of these StatCan tables have multiple data types, so we will only consider **Housing.estimates** = _"Housing starts"_ and **Type.of.unit ** = _"Total units"_.

Notice that Ottawa-Gatineau is split into ON and QC parts.

Let's use the string split function to split apart the province and city. Considering the **GEO** location **"Ottawa-Gatineau, Ontario part, Ontario/Quebec"** and splitting at the ",", we will have to specify that we want to split at the first comma. Also note that location "Census metropolitan area" does not contain province information, so 'None' will appear in that column.

```{python tidy dataset}

# Build the city and province columns by splitting at the first comma - notice the space after the comma
housing[['city', 'province']] = housing['GEO'].str.split(', ', n=1, expand=True)


# Now handle the "Ontario part", "Quebec part" entries
# Discard everything after first space
housing["province"] = housing["province"].str.split(" p").str[0]

housing.head()
```

#### Preparing for Merging Datasets

Here we rebuild the dataset and sum housing starts within provinces

```{python prepare for merge}

# Drop all data except Housing Starts and Total Units
# Rename VALUE Housing start so we know what housing parameter we are looking at

housing_starts = housing[(housing["Housing estimates"] == "Housing starts") &
                  (housing["Type of unit"] == "Total units")]

housing_starts = housing_starts.rename(columns = {"VALUE" : "Housing starts"})

housing_starts["year"] = housing_starts["REF_DATE"].dt.year
housing_starts["month"] = housing_starts["REF_DATE"].dt.month

housing_starts = housing_starts.groupby(["province",
                               "year",
                               "month",
                               "REF_DATE"],
                               as_index = False,)["Housing starts"].sum()

housing_starts.head()

```

```{python merge}

unemployment = provinces[["GEO", "REF_DATE", "VALUE", "month", "year", "decade"]]


unemployment = unemployment.rename(columns = {"VALUE" : "unemployment rate", 
                                              "GEO" : "province"})

unemployment.head()

```

```{python merge2}


merged = pd.merge(unemployment, housing_starts, on = ['province', 'year', 'month', 'REF_DATE'])

#merged.tail()

merged["province"].unique()

```